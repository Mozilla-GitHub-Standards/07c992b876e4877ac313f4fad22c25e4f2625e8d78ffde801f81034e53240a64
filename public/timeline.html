<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Haiku: Timeline</title>
  <style>
    table {
      border: 1px solid #ccc;
    }
    td, th {
      outline: 1px solid #ccc;
      padding: 2px 8px;
      text-align: center;
    }
    canvas {
      width: auto;
    }
  </style>
</head>
<body>

<div id="timeline"></div>

<table id="tabular">
</table>

<script src="js/util.js"></script>
<script src="js/data-series.js"></script>
<script src="js/table.js"></script>
<script src="js/timeline.js"></script>
<script>
'use strict';
function printUsage() {
    var container = document.getElementById('timeline');
    var p1 = document.createElement('p');
    p1.textContent = 'No lookup.json found, no id querystring given';
    container.appendChild(p1);

    var p2 = document.createElement('p');
    p2.innerHTML = 'Usage: ' +
    '<a href="timeline.html?id=1a">timeline.html?id=1a</a>'
    ' where 1a.json is a file in the ./logs/ directory, produced by running a' +
    ' PDF report from AT&T through scraperJSON.py';
    container.appendChild(p2);
}

function createSeries(allData) {
  console.log('createSeries from data:', allData);
  var aggregateData = {
    types: []
  };
  var uniqTypes = {};
  var labels = {
    'incomingSMS': 'Incoming SMS',
    'outgoingSMS': 'Outgoing SMS',
    'incomingCall': 'Incoming Calls',
    'outgoingCall': 'Outgoing Calls'
  };
  allData.forEach(function(dataset, i) {
    var suffix = ['A', 'B', '!'][i];
    Object.keys(dataset).forEach(function(type) {
      var label = labels[type];
      if (!label) {
        return;
      }
      var coln = dataset[type];
      var uniqType = type+suffix;
      uniqTypes[uniqType] = uniqType;

      aggregateData[uniqType] = DataSeries.create(coln, {
        type: type,
        uniqType: uniqType,
        label: suffix+': '+label
      });
    });
  });
  // interleave, e.g. outgoing A, incoming B, outgoing A, incoming B
  Object.keys(uniqTypes).filter(function(type) {
    return type.endsWith('B');
  }).forEach(function(typeB) {
    var typeA = typeB.replace(/(incoming|outgoing)(.+)B$/, function(m, direction, type) {
      if (direction === 'incoming') {
        return 'outgoing' + type + 'A';
      } else {
        return 'incoming' + type + 'A';
      }
    });
    console.log('typeA: ', typeA, typeB);
    if (typeB in uniqTypes) {
      aggregateData.types.push(typeA);
    }
    aggregateData.types.push(typeB);
  });
  console.log('aggregateData.types: ', aggregateData.types);
  return aggregateData;
}

var participantId = util.getParamfromQueryString(location.search.substring(1), 'id');
var chartDataSeries;

if (!participantId) {
  showMenu();
} else {
  var pairId = parseInt(participantId);
  var deviceIds = [pairId+'a', pairId+'b'];
  Promise.all(deviceIds.map(function(id) {
    return window.fetch('./logs/' + id + '.json');
  })).then(function(results) {
    var respA = results[0];
    var respB = results[0];
    var jsonPromises = [];
    results.forEach(function(resp, i) {
      var id = deviceIds[i];
      if ((''+resp.status).startsWith('2')) {
        jsonPromises.push(resp.json());
      } else {
        // no data in response, sub in empty dataset
        var emptyDataset = {
          requestError: resp.status,
          deviceId: id, incomingCall: [], incomingSMS: [], outgoingCall: [], outgoingSMS: []
        };
        jsonPromises.push(Promise.resolve(emptyDataset));
      }
    });
    Promise.all(jsonPromises).then(function(results) {
      if (results[0].requestError && results[1].requestError) {
        var container = document.getElementById('timeline');
        deviceIds.forEach(function(id) {
          var p1 = document.createElement('p');
          console.log('Error loading '+id, resp.statusText);
          p1.textContent = 'Error loading JSON for '+id + ': '+resp.statusText;
          container.appendChild(p1);
        });
      } else {
        var chartData = createSeries(results);
        console.log('chartData: ', chartData);
        var chart = chartEachSeries(chartData);
        if (1) {
          var tableOpts = {};
          var tableView = Table.create(tableOpts);
          tableView.draw(
            document.getElementById('tabular'),
            chartData.types.map(function(type) {
              return chartData[type];
            })
          );
        }
      }
    });
  });
}

function showMenu() {
  window.fetch('./logs/index.json').then(function(resp) {
    resp.json().then(function(filenames) {
      var container = document.getElementById('timeline');
      filenames.sort(function(a, b) {
        var ai = parseInt(a);
        var bi = parseInt(b);
        if (ai < bi) {
          return -1;
        } else if (ai > bi) {
          return 1;
        } else {
          return a < b ? -1 : 1;
        }
      });
      filenames.forEach(function(name) {
        var id = name.replace(/\.json$/, '');
        var p = document.createElement('p');
        var a = document.createElement('a');
        a.textContent = id;
        a.href = 'timeline.html?id='+id;
        p.appendChild(a);
        container.appendChild(p);
      });
    });
  }).catch(function(e) {
    printUsage();
  });
  var selfLink
  console.log('usage: html-timeline.html?id=1a');

}
function chartEachSeries(chartData) {
  console.log('chartEachSeries: chartData: ', chartData);
  var firstDate, lastDate;
  var allSeries = chartData.types.map(function(type) {
    return chartData[type];
  });
  allSeries.forEach(function(series) {
    if (!firstDate || series.firstDate < firstDate) {
      firstDate = series.firstDate;
    }
    if (!lastDate || series.lastDate > lastDate) {
      lastDate = series.lastDate;
    }
  });

  var chartOpts = {
    width: 2000,
    height: 50*(allSeries.length+1),
    xOffset: 10,
    scale: 30,
    seriesStyles: chartData.types.map(function(type) {
      switch (type) {
        case 'incomingSMSA':
        case 'incomingSMSB':
          return {fillStyle: 'green'};
        case 'outgoingSMSA':
        case 'outgoingSMSB':
          return {fillStyle: 'blue'};
        case 'incomingCallA':
        case 'incomingCallB':
          return {fillStyle: 'orange'};
        case 'outgoingCallA':
        case 'outgoingCallB':
          return {fillStyle: 'red'};
        default:
          console.log('Unexpected data series: ', type);
          return {fillStyle: 'grey'};
      }
    }),
    axisStyle: {fillStyle: '#999'},
    startDate: util.startOfDay(firstDate),
    endDate: new Date(util.startOfDay(lastDate).getTime() + util.DAY_MS - 1)
  };
  console.log('firstDate:', firstDate);
  console.log('lastDate:', lastDate);

  var timelineChart = Timeline.create(chartOpts);
  timelineChart.draw(document.getElementById('timeline'), allSeries);
}

</script>
</body>
</html>
